get_coef(tuning_parameter = lasso_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
plot_coef_heatmap()
t[[1]]
tb %>% filter(tag == 1) %>% plot_coef()
tb =
lasso_cv %>%
get_coef(tuning_parameter = lasso_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2), c(59,58)))
tb %>% filter(tag == 1) %>% plot_coef()
tag = rep(c(1,2), c(59,58))
tag
plot_coef <- function(coef_table){
coef_table %>%
reshape2::melt(id.vars = "feature") %>%
ggplot(aes(x = feature, y = value, color = variable)) +
geom_point(size = 1) +
geom_hline(yintercept = 0, size = 5, alpha = 0.3, color = "grey50") +
scale_color_nejm() +
facet_wrap(variable~., nrow=1) +
labs(x = "", y = "Coefficient", color = "Group") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90)) +
coord_flip()
}
tb =
lasso_cv %>%
get_coef(tuning_parameter = lasso_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2), c(59,58)))
tb %>% filter(tag == 1) %>% plot_coef()
plot_coef <- function(coef_table){
coef_table %>%
reshape2::melt(id.vars = c("feature","tag")) %>%
ggplot(aes(x = feature, y = value, color = variable)) +
geom_point(size = 1) +
geom_hline(yintercept = 0, size = 5, alpha = 0.3, color = "grey50") +
scale_color_nejm() +
facet_wrap(variable~., nrow=1) +
labs(x = "", y = "Coefficient", color = "Group") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90)) +
coord_flip()
}
tb %>% filter(tag == 1) %>% plot_coef()
117/3
anion = "O"
X = data[data$X == anion,-c(1,2)] %>% remove_identical_cal() %>% as.matrix()
Y = data$GroupCat[data$X == anion] %>% as.matrix()
folds <- createFolds(1:nrow(X), k = 5, list = TRUE, returnTrain = FALSE)
dim(X)
View(X)
102/3
102/2
102/3
34*3
ridge_cv <- cv.glmnet(x = X, y = Y, alpha = 0, nfolds = 5, type.measure = "deviance", family = "multinomial")
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), 34))
tb =
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), 34))
tb %>% filter(tag == 1) %>% plot_coef()
anion = "F"
X = data[data$X == anion,-c(1,2)] %>% remove_identical_cal() %>% as.matrix()
Y = data$GroupCat[data$X == anion] %>% as.matrix()
folds <- createFolds(1:nrow(X), k = 5, list = TRUE, returnTrain = FALSE)
dim(X)
88/2
88/3
126/3
knitr::opts_chunk$set(
fig.align = "center",
fig.pos = "H",
fig.width = 10,
fig.height = 10,
message = FALSE,
warning = FALSE,
external = TRUE,
echo = FALSE
)
library(tidyverse)
library(magrittr)
library(ggsci)
library(kableExtra)
library(glmnet)
library(caret)
source("../scripts/functions.R")
knitr::opts_chunk$set(
fig.align = "center",
fig.pos = "H",
fig.width = 10,
fig.height = 10,
message = FALSE,
warning = FALSE,
external = TRUE,
echo = FALSE
)
library(tidyverse)
library(magrittr)
library(ggsci)
library(kableExtra)
library(glmnet)
library(caret)
source("./scripts/functions.R")
# load raw data files
data <- read.csv("./data/filledDatabase.csv")[,-c(2:9,11:13)]
# clean data
data <- clean_data(data) %>% collapse_data()
# separate compound and group_cate from the predictors
compound <- data$Compound
group_cat <- data$GroupCat
space_group <- data$SpaceGroup
# create data constructed by first 13 PC's
data <- select(data, -c("Compound","Z","SpaceGroup","SpaceGroupNumber"))
ridge_cv <- cv.glmnet(x = X, y = Y, alpha = 0, nfolds = 5, type.measure = "deviance", family = "multinomial")
tb =
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), 39))
ridge_cv <- cv.glmnet(x = X, y = Y, alpha = 0, nfolds = 5, type.measure = "deviance", family = "multinomial")
tb =
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), 39))
ridge_cv <- cv.glmnet(x = X, y = Y, alpha = 0, nfolds = 5, type.measure = "deviance", family = "multinomial")
X = data[,-c(1,2)] %>% remove_identical_cal() %>% as.matrix()
Y = data$GroupCat %>% as.matrix()
ridge_cv <- cv.glmnet(x = X, y = Y, alpha = 0, nfolds = 5, type.measure = "deviance", family = "multinomial")
tb =
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), 39))
tb %>% filter(tag == 1) %>% plot_coef()
tb %>% filter(tag == 2) %>% plot_coef()
tb %>% filter(tag == 3) %>% plot_coef()
tag = rep(c(1,2,3), 39)
rep(c(1,2,3), 39)
tb =
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), each=39))
rep(c(1,2,3), each=39)
tb =
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), each=39))
tb %>% filter(tag == 1) %>% plot_coef()
tb %>% filter(tag == 2) %>% plot_coef()
tb %>% filter(tag == 3) %>% plot_coef()
lasso_cv <- cv.glmnet(x = X, y = Y, alpha = 1, nfolds = 5, type.measure = "deviance", family = "multinomial")
tb =
lasso_cv %>%
get_coef(tuning_parameter = lasso_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), 39))
tb =
lasso_cv %>%
get_coef(tuning_parameter = lasso_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), each = 39))
tb %>% filter(tag == 1) %>% plot_coef()
tb %>% filter(tag == 2) %>% plot_coef()
tb %>% filter(tag == 3) %>% plot_coef()
rep(c(1,2,3), each = 39)
tb %>% filter(tag == 1) %>% plot_coef()
tb %>% filter(tag == 3) %>% plot_coef()
lasso_cv <- cv.glmnet(x = X, y = Y, alpha = 1, nfolds = 5, type.measure = "deviance", family = "multinomial")
tb =
lasso_cv %>%
get_coef(tuning_parameter = lasso_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), each = 39))
elastic_cv <-
train(GroupCat ~., data = data, method = "glmnet",
trControl = trainControl("cv", number = 5),
tuneLength = 10
)
tb =
elastic_cv$finalModel %>%
get_coef(tuning_parameter = elastic_cv$bestTune$lambda) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), each = 39))
tb =
elastic_cv$finalModel %>%
get_coef(tuning_parameter = elastic_cv$bestTune$lambda) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)")
View(tb)
tb =
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)")
elastic_cv$finalModel
elastic_cv$finalModel %>%
get_coef(tuning_parameter = elastic_cv$bestTune$lambda)
data.frame(X,Y)
elastic_cv <-
train(GroupCat ~., data = data.frame(X,Y), method = "glmnet",
trControl = trainControl("cv", number = 5),
tuneLength = 10)
elastic_cv <-
train(GroupCat ~., data = data.frame(X,GroupCat=Y), method = "glmnet",
trControl = trainControl("cv", number = 5),
tuneLength = 10)
tb =
elastic_cv$finalModel %>%
get_coef(tuning_parameter = elastic_cv$bestTune$lambda) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), each = 39))
tb %>% filter(tag == 3) %>% plot_coef()
tb %>% filter(tag == 2) %>% plot_coef()
tb %>% filter(tag == 1) %>% plot_coef()
folds = createFolds(1:nrow(X), k = 5, list = TRUE, returnTrain = FALSE)
tb_ridge = prediction_table(alpha = 0, lambda = ridge_cv$lambda.min)
tb_ridge$r %>% print_accurate_tb()
tb_ridge$t %>% highlight_tb_count()
tb_ridge$t %>% highlight_tb_percent()
tb_lasso = prediction_table(alpha = 1, lambda = lasso_cv$lambda.min)
tb_lasso$r %>% print_accurate_tb()
tb_lasso$t %>% highlight_tb_count()
tb_lasso$t %>% highlight_tb_percent()
tb_elastic = prediction_table(alpha = elastic_cv$bestTune[[1]], lambda = elastic_cv$bestTune[[2]])
tb_elastic$r %>% print_accurate_tb()
tb_elastic$t %>% highlight_tb_count()
tb_elastic$t %>% highlight_tb_percent()
anion = "O"
X = data[data$X == anion,-c(1,2)] %>% remove_identical_cal() %>% as.matrix()
Y = data$GroupCat[data$X == anion] %>% as.matrix()
folds <- createFolds(1:nrow(X), k = 5, list = TRUE, returnTrain = FALSE)
ridge_cv <- cv.glmnet(x = X, y = Y, alpha = 0, nfolds = 5, type.measure = "deviance", family = "multinomial")
tb =
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), each = 34))
tb %>% filter(tag == 3) %>% plot_coef()
tb %>% filter(tag == 2) %>% plot_coef()
tb %>% filter(tag == 1) %>% plot_coef()
tb %>% filter(tag == 2) %>% plot_coef()
tb =
lasso_cv %>%
get_coef(tuning_parameter = lasso_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), each=34))
dim(X)
anion = "O"
X = data[data$X == anion,-c(1,2)] %>% remove_identical_cal() %>% as.matrix()
Y = data$GroupCat[data$X == anion] %>% as.matrix()
folds <- createFolds(1:nrow(X), k = 5, list = TRUE, returnTrain = FALSE)
ridge_cv <- cv.glmnet(x = X, y = Y, alpha = 0, nfolds = 5, type.measure = "deviance", family = "multinomial")
dim(X)
102/3
ridge_cv <- cv.glmnet(x = X, y = Y, alpha = 0, nfolds = 5, type.measure = "deviance", family = "multinomial")
tb =
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), each = 34))
tb %>% filter(tag == 3) %>% plot_coef()
rep(c(1,2,3), each = 34)
tb %>% filter(tag == 3) %>% plot_coef()
tb %>% filter(tag == 2) %>% plot_coef()
X = data[,-c(1,2)] %>% remove_identical_cal() %>% as.matrix()
Y = data$GroupCat %>% as.matrix()
names(X)
names(data)
anion = "O"
X = data[data$X == anion,-c(1,2)] %>% remove_identical_cal() %>% as.matrix()
Y = data$GroupCat[data$X == anion] %>% as.matrix()
folds <- createFolds(1:nrow(X), k = 5, list = TRUE, returnTrain = FALSE)
ridge_cv <- cv.glmnet(x = X, y = Y, alpha = 0, nfolds = 5, type.measure = "deviance", family = "multinomial")
tb =
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), each = 34))
tb %>% filter(tag == 3) %>% plot_coef()
tb %>% filter(tag == 2) %>% plot_coef()
tb %>% filter(tag == 1) %>% plot_coef()
lasso_cv <- cv.glmnet(x = X, y = Y, alpha = 1, nfolds = 5, type.measure = "deviance", family = "multinomial")
tb =
lasso_cv %>%
get_coef(tuning_parameter = lasso_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), each=34))
34*3
tb %>% filter(tag == 3) %>% plot_coef()
tb %>% filter(tag == 2) %>% plot_coef()
tb %>% filter(tag == 1) %>% plot_coef()
elastic_cv <-
train(GroupCat ~., data = data.frame(X, GroupCat=Y), method = "glmnet",
trControl = trainControl("cv", number = 5),
tuneLength = 10
)
elastic_cv$finalModel %>%
get_coef(tuning_parameter = elastic_cv$bestTune$lambda) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), 34))
tb =
elastic_cv$finalModel %>%
get_coef(tuning_parameter = elastic_cv$bestTune$lambda) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), 34))
tb =
elastic_cv$finalModel %>%
get_coef(tuning_parameter = elastic_cv$bestTune$lambda) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2,3), each=34))
tb %>% filter(tag == 3) %>% plot_coef()
tb %>% filter(tag == 2) %>% plot_coef()
tb %>% filter(tag == 1) %>% plot_coef()
tb_ridge = prediction_table(alpha = 0, lambda = ridge_cv$lambda.min)
tb_ridge$r %>% print_accurate_tb()
tb_ridge$t %>% highlight_tb_count()
tb_ridge$t %>% highlight_tb_percent()
tb_lasso = prediction_table(alpha = 1, lambda = lasso_cv$lambda.min)
tb_lasso$r %>% print_accurate_tb()
tb_lasso$t %>% highlight_tb_count()
tb_lasso$t %>% highlight_tb_percent()
tb_elastic = prediction_table(alpha = elastic_cv$bestTune[[1]], lambda = elastic_cv$bestTune[[2]])
tb_elastic$r %>% print_accurate_tb()
tb_elastic$t %>% highlight_tb_count()
tb_elastic$t %>% highlight_tb_percent()
anion = "F"
X = data[data$X == anion,-c(1,2)] %>% remove_identical_cal() %>% as.matrix()
Y = data$GroupCat[data$X == anion] %>% as.matrix()
folds <- createFolds(1:nrow(X), k = 5, list = TRUE, returnTrain = FALSE)
ridge_cv <- cv.glmnet(x = X, y = Y, alpha = 0, nfolds = 5, type.measure = "deviance", family = "multinomial")
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2), each=44))
ridge_cv <- cv.glmnet(x = X, y = Y, alpha = 0, nfolds = 5, type.measure = "deviance", family = "multinomial")
tb =
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2), each=44))
tb =
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2), each=44))
tb %>% filter(tag == 3) %>% plot_coef()
tb %>% filter(tag == 1) %>% plot_coef()
tb %>% filter(tag == 2) %>% plot_coef()
lasso_cv <- cv.glmnet(x = X, y = Y, alpha = 1, nfolds = 5, type.measure = "deviance", family = "multinomial")
tb =
lasso_cv %>%
get_coef(tuning_parameter = lasso_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2), each=44))
tb %>% filter(tag == 2) %>% plot_coef()
tb %>% filter(tag == 1) %>% plot_coef()
elastic_cv <-
train(GroupCat ~., data = data, method = "glmnet",
trControl = trainControl("cv", number = 5),
tuneLength = 10)
tb =
elastic_cv$finalModel %>%
get_coef(tuning_parameter = elastic_cv$bestTune$lambda) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2), each=44))
elastic_cv <-
train(GroupCat ~., data = data.frame(X,GroupCat=Y), method = "glmnet",
trControl = trainControl("cv", number = 5),
tuneLength = 10)
tb =
elastic_cv$finalModel %>%
get_coef(tuning_parameter = elastic_cv$bestTune$lambda) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2), each=44))
tb %>% filter(tag == 2) %>% plot_coef()
tb %>% filter(tag == 1) %>% plot_coef()
tb_ridge = prediction_table(alpha = 0, lambda = ridge_cv$lambda.min)
tb_ridge$r %>% print_accurate_tb()
tb_ridge$t %>% highlight_tb_count()
tb_ridge$t %>% highlight_tb_percent()
tb_lasso = prediction_table(alpha = 1, lambda = lasso_cv$lambda.min)
tb_lasso$r %>% print_accurate_tb()
tb_lasso$t %>% highlight_tb_count()
tb_lasso$t %>% highlight_tb_percent()
tb_elastic = prediction_table(alpha = elastic_cv$bestTune[[1]], lambda = elastic_cv$bestTune[[2]])
tb_elastic$r %>% print_accurate_tb()
tb_elastic$t %>% highlight_tb_count()
tb_elastic$t %>% highlight_tb_percent()
anion = "F"
X = data[data$X == anion,-c(1,2)] %>% remove_identical_cal() %>% as.matrix()
Y = data$GroupCat[data$X == anion] %>% as.matrix()
folds <- createFolds(1:nrow(X), k = 5, list = TRUE, returnTrain = FALSE)
ridge_cv <- cv.glmnet(x = X, y = Y, alpha = 0, nfolds = 5, type.measure = "deviance", family = "multinomial")
tb =
ridge_cv %>%
get_coef(tuning_parameter = ridge_cv$lambda.min) %>%
select(feature, Cubic, Tilted, Others) %>%
filter(feature != "(Intercept)") %>%
mutate(tag = rep(c(1,2), each=44))
tb %>% filter(tag == 2) %>% plot_coef()
tb %>% filter(tag == 1) %>% plot_coef()
tb_ridge = prediction_table(alpha = 0, lambda = ridge_cv$lambda.min)
tb_ridge = prediction_table(alpha = 0, lambda = ridge_cv$lambda.min)
alpha = 0
lambda = ridge_cv$lambda.min
ridge_cv$lambda.min
t = lapply(folds, function(id) {
X_test = X[id,]; X_train = X[-id,]
Y_test = Y[id]; Y_train = Y[-id]
model = glmnet(x = X_train, y = Y_train, alpha = alpha, family = "multinomial")
Y_pred = predict(model, newx = X_test, type = "class", s = lambda)
table(factor(Y_pred, levels = levels(factor(Y))), factor(Y_test))
})
r = lapply(t, function(x) sum(diag(x))/sum(x)) %>% unlist()
t = Reduce("+",t) %>% as.matrix()
r
t
t = lapply(folds, function(id) {
X_test = X[id,]; X_train = X[-id,]
Y_test = Y[id]; Y_train = Y[-id]
model = glmnet(x = X_train, y = Y_train, alpha = alpha, family = "multinomial")
Y_pred = predict(model, newx = X_test, type = "class", s = lambda)
table(factor(Y_pred, levels = levels(factor(data$GroupCat))), factor(Y_test))
})
r = lapply(t, function(x) sum(diag(x))/sum(x)) %>% unlist()
t = Reduce("+",t) %>% as.matrix()
t
factor(data$GroupCat)
levels(factor(data$GroupCat)))
levels(factor(data$GroupCat))
t = lapply(folds, function(id) {
X_test = X[id,]; X_train = X[-id,]
Y_test = Y[id]; Y_train = Y[-id]
model = glmnet(x = X_train, y = Y_train, alpha = alpha, family = "multinomial")
Y_pred = predict(model, newx = X_test, type = "class", s = lambda)
table(factor(Y_pred, levels = levels(factor(data$GroupCat))), factor(Y_test))
})
t
t = lapply(folds, function(id) {
X_test = X[id,]; X_train = X[-id,]
Y_test = Y[id]; Y_train = Y[-id]
model = glmnet(x = X_train, y = Y_train, alpha = alpha, family = "multinomial")
Y_pred = predict(model, newx = X_test, type = "class", s = lambda)
table(factor(Y_pred, levels = levels(factor(data$GroupCat))),
factor(Y_test, levels = levels(factor(data$GroupCat))))
})
r = lapply(t, function(x) sum(diag(x))/sum(x)) %>% unlist()
t = Reduce("+",t) %>% as.matrix()
prediction_table <- function(alpha, lambda){
t = lapply(folds, function(id) {
X_test = X[id,]; X_train = X[-id,]
Y_test = Y[id]; Y_train = Y[-id]
model = glmnet(x = X_train, y = Y_train, alpha = alpha, family = "multinomial")
Y_pred = predict(model, newx = X_test, type = "class", s = lambda)
table(factor(Y_pred, levels = levels(factor(data$GroupCat))),
factor(Y_test, levels = levels(factor(data$GroupCat))))
})
r = lapply(t, function(x) sum(diag(x))/sum(x)) %>% unlist()
t = Reduce("+",t) %>% as.matrix()
return(list(r=r, t=t))
}
tb_ridge = prediction_table(alpha = 0, lambda = ridge_cv$lambda.min)
tb_ridge$r %>% print_accurate_tb()
tb_ridge$t %>% highlight_tb_count()
tb_ridge$t %>% highlight_tb_percent()
tb_lasso = prediction_table(alpha = 1, lambda = lasso_cv$lambda.min)
tb_lasso$r %>% print_accurate_tb()
tb_lasso$t %>% highlight_tb_count()
tb_lasso$t %>% highlight_tb_percent()
tb_elastic = prediction_table(alpha = elastic_cv$bestTune[[1]], lambda = elastic_cv$bestTune[[2]])
tb_elastic$r %>% print_accurate_tb()
tb_elastic$t %>% highlight_tb_count()
tb_elastic$t %>% highlight_tb_percent()
